#include <inttypes.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define LIMIT 1000000007ULL

typedef struct tree_node {
  struct tree_node *parent;
  uint32_t num;
  int32_t depth;
} tree_node;

typedef struct aux_info {
  uint64_t simple_sum;
  uint64_t level_sum;
  uint8_t marker;
} aux_info;

static void add_depth(tree_node *node) {
  if (node->parent == NULL) {
    node->depth = 0;
  } else if (node->depth == -1) {
    add_depth(node->parent);
    node->depth = node->parent->depth + 1;
  }
}

static int order_tree(const void *lhs, const void *rhs) {
  tree_node *a = *((tree_node **)lhs);
  tree_node *b = *((tree_node **)rhs);
  return (int)(a->depth - b->depth);
}

int main(void) {
  long num_nodes, num_queries;
  if (scanf("%ld %ld", &num_nodes, &num_queries) != 2) {
    return 0;
  }
  if (num_nodes <= 0) return 0;

  tree_node *nodes = calloc((size_t)num_nodes, sizeof(tree_node));
  if (!nodes) return 0;
  tree_node **order = calloc((size_t)num_nodes, sizeof(tree_node *));
  if (!order) {
    free(nodes);
    return 0;
  }
  aux_info *info = calloc((size_t)num_nodes, sizeof(aux_info));
  if (!info) {
    free(nodes);
    free(order);
    return 0;
  }

  for (long i = 0; i < num_nodes; ++i) {
    nodes[i].num = (uint32_t)(i + 1);
    nodes[i].depth = -1;
    nodes[i].parent = NULL;
    order[i] = &nodes[i];
  }

  for (long i = 0; i < num_nodes - 1; ++i) {
    long a, b;
    if (scanf("%ld %ld", &a, &b) != 2) {
      // malformed input
      free(nodes);
      free(order);
      free(info);
      return 0;
    }
    tree_node *node_a = &nodes[a - 1];
    tree_node *node_b = &nodes[b - 1];
    if (node_b->parent == NULL && node_a != node_b) {
      node_b->parent = node_a;
    } else if (node_a->parent == NULL && node_a != node_b) {
      node_a->parent = node_b;
    } else {
      // This should not happen for a valid tree input
      // but we simply continue
    }
  }

  for (long i = 0; i < num_nodes; ++i) {
    add_depth(&nodes[i]);
  }

  qsort(order, (size_t)num_nodes, sizeof(tree_node *), order_tree);

  for (long qi = 0; qi < num_queries; ++qi) {
    long k;
    if (scanf("%ld", &k) != 1) break;
    /* mark the nodes for this query */
    for (long j = 0; j < k; ++j) {
      long node_num;
      if (scanf("%ld", &node_num) != 1) {
        node_num = -1;
      }
      if (node_num >= 1 && node_num <= num_nodes) {
        info[node_num - 1].marker = 1;
      }
    }

    uint64_t total = 0;

    /* process nodes bottom-up (deepest first) */
    for (long j = num_nodes - 1; j >= 0; --j) {
      /* make a local copy of the node (pointer fields remain valid) */
      tree_node node = *order[j];
      uint64_t node_num = (uint64_t)node.num;
      size_t node_index = (size_t)(node_num - 1);

      aux_info node_info = info[node_index];
      if (node_info.marker == 0 && node.depth == 0) {
        /* nothing to propagate from an unmarked leaf root-level node */
        if (j == 0) break; /* avoid infinite loop when j is signed */
        continue;
      }

      uint64_t node_simple_sum = node_info.simple_sum;
      uint64_t node_level_sum = node_info.level_sum;

      if (node_info.marker != 0) {
        /* Add all combinations made with this node and its current children */
        total += (node_level_sum * node_num) % LIMIT;
        if (total >= LIMIT) total %= LIMIT;
        node_simple_sum += node_num;
        if (node_simple_sum >= LIMIT) node_simple_sum %= LIMIT;
      } else if (node_simple_sum == 0) {
        /* no contribution from this subtree */
        if (j == 0) break;
        continue;
      }

      /* Increment the accumulated level-sum by the simple sum at this node */
      node_level_sum += node_simple_sum;
      if (node_level_sum >= LIMIT) node_level_sum %= LIMIT;

      tree_node *parent = node.parent;
      if (parent != NULL) {
        size_t parent_index = (size_t)(parent->num - 1);

        uint64_t parent_simple_sum = info[parent_index].simple_sum;
        uint64_t parent_level_sum = info[parent_index].level_sum;

        /* Add the combinations that this subtree makes with previously processed sibling subtrees */
        uint64_t add1 = (parent_simple_sum * node_level_sum) % LIMIT;
        uint64_t add2 = (parent_level_sum * node_simple_sum) % LIMIT;
        total = (total + add1 + add2) % LIMIT;

        parent_simple_sum += node_simple_sum;
        if (parent_simple_sum >= LIMIT) parent_simple_sum %= LIMIT;

        parent_level_sum += node_level_sum;
        if (parent_level_sum >= LIMIT) parent_level_sum %= LIMIT;

        info[parent_index].simple_sum = parent_simple_sum;
        info[parent_index].level_sum = parent_level_sum;
      }

      /* store back the node's computed sums (in case parent or other use expects them later) */
      info[node_index].simple_sum = node_simple_sum;
      info[node_index].level_sum = node_level_sum;

      if (j == 0) break; /* safe exit for signed loop */
    }

    /* clear markers and sums for next query */
    for (long i = 0; i < num_nodes; ++i) {
      info[i].simple_sum = 0;
      info[i].level_sum = 0;
      info[i].marker = 0;
    }

    printf("%" PRIu64 "\n", total % LIMIT);
  }

  free(nodes);
  free(order);
  free(info);

  return 0;
}
